import osimport scipy.io as sioimport timeimport argparseimport pandas as pdimport numpy as npimport torchimport warningswarnings.filterwarnings("ignore")if __name__ == '__main__':    parser = argparse.ArgumentParser()    parser.add_argument('--source_dir', type=str, default='data_predicted', help='where test files are stored')   # file/folder, 0 for webcam    parser.add_argument('--model', type=str, default="./checkpoints/best_SNR_0_rand7.pt")    parser.add_argument('--feature_size', type=int, default=512, help='feature_size')    args = parser.parse_args()    print(args)    # Test image folder    source = args.source_dir + os.sep    sub_content=os.listdir(source)[0]    file_names = os.listdir(os.path.join(source,sub_content))    len_file_names = len(file_names)   # 子文件夹的数量    for i in range(len_file_names):        sub_XYImages_path = os.path.join(source, sub_content, file_names[i])        mat_file = os.listdir(sub_XYImages_path)        # if os.path.splitext(item_name)[1] in ['.mat']        # audios.sort(key=lambda x: int(x.split('.')[0]))        XYImages_path=[]        for j in range(len(mat_file)):            XYImages_path.append(os.path.join(sub_XYImages_path,mat_file[j]))        # Result list        predict_list = []        device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')        model = torch.load(args.model, map_location=device)        print('Load Model Done!!!')        file_count = 0        start_time = time.time()        with torch.no_grad():            model.eval()            for file in XYImages_path:                # audio_path = os.path.join(source, file)                file = file.split(".")[0]                feature_loader = sio.loadmat                fmap = feature_loader(file)["signal_r"]                fmap = torch.from_numpy(fmap)                fmap = torch.unsqueeze(fmap, 0)                fmap = torch.unsqueeze(fmap, 0)                fmap = fmap.to(device).float()                model.to(device)                out = model(fmap)                # preds = F.softmax(out, dim=1) # compute softmax                # print(preds)                # prod, index = torch.max(preds, 1)                pred_labels = torch.squeeze(out).cpu().numpy()                predict_list.append(pred_labels)                # result = process_prediction(sigmoid.cpu().numpy()[0])                # print(f"{file} -> sigmoid: {list(np.round(sigmoid.cpu().numpy()[0], 2))}")                # print(f"{file} -> result: {pred_labels}")                pathname = os.path.join("output" + os.sep, sub_content, file_names[i])                os.makedirs(pathname, mode=0o777, exist_ok=True)            for index,path in enumerate(mat_file):                predicted = predict_list[index]                sio.savemat(pathname+os.sep + path, {"Height": predicted})